'use server'

import { createClient } from '@/lib/supabase/server'
import { createAdminClient } from '@/lib/supabase/admin'
import { redirect } from 'next/navigation'
import { cookies } from 'next/headers'
// Define OTP types that match Supabase
type OtpType = 'signup' | 'recovery' | 'email_change'
import { OrganizationType } from '@/lib/types'

export async function createUserProfile(userId: string, data: {
  full_name: string
  organization_id: string
  role: 'DISPATCHER' | 'CARRIER_ADMIN'
}) {
  const supabase = await createClient()
  
  const { error } = await supabase
    .from('profiles')
    .insert({
      id: userId,
      full_name: data.full_name,
      organization_id: data.organization_id,
      role: data.role
    })

  if (error) {
    console.error('Error creating profile:', error)
    throw error
  }
}

export async function getCurrentUser() {
  const supabase = await createClient()
  
  const { data: { user }, error } = await supabase.auth.getUser()
  
  if (error || !user) {
    return null
  }

  // Get user profile with organization
  const { data: profile } = await supabase
    .from('profiles')
    .select(`
      *,
      organization:organizations(*)
    `)
    .eq('id', user.id)
    .single()

  return {
    id: user.id,
    email: user.email!,
    profile
  }
}

export async function signOut() {
  const supabase = await createClient()
  await supabase.auth.signOut()
  redirect('/login')
}

function getDefaultPageForRole(role: string): string {
  switch (role) {
    case 'DISPATCHER':
      return '/dispatcher'
    case 'CARRIER_ADMIN':
      return '/carrier-admin'
    default:
      return '/dashboard'
  }
}

export async function redirectToRolePage() {
  const user = await getCurrentUser()
  
  if (!user?.profile?.role) {
    redirect('/login')
  }

  const defaultPage = getDefaultPageForRole(user.profile.role)
  redirect(defaultPage)
}

interface NewOrganizationData {
  // User data
  fullName: string
  email: string
  password: string
  organizationType: OrganizationType
  
  // Organization data
  companyName: string
  taxCode: string
  address: string
  phoneNumber: string
  representativeEmail: string
}

// Temporary storage for user registration data (in practice, use Redis or similar)
const tempRegistrationData = new Map<string, {
  data: NewOrganizationData
  timestamp: number
  otpCode?: string
}>()

export async function requestNewOrganization(data: NewOrganizationData) {
  try {
    console.log('üöÄ Starting requestNewOrganization with email:', data.email)
    const supabase = await createClient()

    // Step 1: Check if user already exists first
    console.log('üîç Checking if user already exists...')
    const { data: existingUser, error: checkError } = await supabase
      .from('profiles')
      .select('id, full_name')
      .eq('email', data.email)
      .single()

    if (existingUser) {
      return { 
        success: false, 
        message: `Email "${data.email}" ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω tr∆∞·ªõc ƒë√≥. Vui l√≤ng s·ª≠ d·ª•ng email kh√°c ho·∫∑c ƒëƒÉng nh·∫≠p n·∫øu b·∫°n c√≥ t√†i kho·∫£n.` 
      }
    }

    // Step 2: Generate and store OTP temporarily
    const otpCode = Math.floor(100000 + Math.random() * 900000).toString() // 6-digit OTP
    console.log('üîë Generated OTP:', otpCode) // For debugging - remove in production
    
    // Store registration data temporarily (expires in 10 minutes)
    const tempKey = data.email
    tempRegistrationData.set(tempKey, {
      data: data,
      timestamp: Date.now(),
      otpCode: otpCode
    })

    // Clean up expired registrations (older than 10 minutes)
    for (const [key, value] of tempRegistrationData.entries()) {
      if (Date.now() - value.timestamp > 10 * 60 * 1000) {
        tempRegistrationData.delete(key)
      }
    }

    // Step 3: Send OTP email using Supabase Edge Function
    console.log('üìß Sending OTP to:', data.representativeEmail)
    console.log('üì± OTP Code for', data.representativeEmail, ':', otpCode)
    
    try {
      const supabase = await createClient()
      
      // Try to send email via Edge Function
      const { data: emailResult, error: emailError } = await supabase.functions.invoke('send-otp-email', {
        body: {
          to: data.representativeEmail,
          otpCode: otpCode,
          fullName: data.fullName,
          companyName: data.companyName
        }
      })

      if (emailError || !emailResult?.success) {
        console.log('‚ö†Ô∏è Email sending failed, but continuing with OTP in console')
        console.log('üì± USE THIS OTP CODE:', otpCode)
        
        return { 
          success: true, 
          message: `Email g·ª≠i kh√¥ng th√†nh c√¥ng. M√£ OTP ƒë·ªÉ test: ${otpCode}`,
          tempKey: tempKey,
          otpCode: otpCode // Include for testing
        }
      }

      console.log('‚úÖ OTP email sent successfully!')
      return { 
        success: true, 
        message: `M√£ OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email: ${data.representativeEmail}`,
        tempKey: tempKey
      }
      
    } catch (emailSendError) {
      console.error('‚ùå Email sending error:', emailSendError)
      console.log('üì± USE THIS OTP CODE:', otpCode)
      
      // Continue registration flow even if email fails
      return { 
        success: true, 
        message: `Kh√¥ng th·ªÉ g·ª≠i email. M√£ OTP ƒë·ªÉ test: ${otpCode}`,
        tempKey: tempKey,
        otpCode: otpCode
      }
    }

  } catch (error: any) {
    console.error('üí• Fatal error in requestNewOrganization:', error)
    return { 
      success: false, 
      message: `L·ªói h·ªá th·ªëng: ${error.message}` 
    }
  }
}

export async function verifyOtp(
  email: string, 
  token: string, 
  type: OtpType,
  organizationId?: string
) {
  try {
    console.log('üîê Starting OTP verification for:', email)
    const supabase = await createClient()

    // Step 1: Get stored registration data
    const tempData = tempRegistrationData.get(email)
    if (!tempData) {
      return { 
        success: false, 
        message: 'D·ªØ li·ªáu ƒëƒÉng k√Ω kh√¥ng t√¨m th·∫•y ho·∫∑c ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng k√Ω l·∫°i.' 
      }
    }

    // Step 2: Verify OTP code
    if (tempData.otpCode !== token) {
      return { 
        success: false, 
        message: 'M√£ OTP kh√¥ng ch√≠nh x√°c. Vui l√≤ng ki·ªÉm tra l·∫°i.' 
      }
    }

    // Step 3: Check if OTP is expired (10 minutes)
    if (Date.now() - tempData.timestamp > 10 * 60 * 1000) {
      tempRegistrationData.delete(email)
      return { 
        success: false, 
        message: 'M√£ OTP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng k√Ω l·∫°i.' 
      }
    }

    console.log('‚úÖ OTP verified successfully')
    const registrationData = tempData.data

    // Step 4: NOW create user account (after OTP verification)
    console.log('üë§ Creating user account after OTP verification...')
    const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
      email: registrationData.email,
      password: registrationData.password,
      options: {
        data: {
          full_name: registrationData.fullName,
          organization_type: registrationData.organizationType,
          email_confirmed: true // Mark as confirmed since we verified OTP
        },
        emailRedirectTo: undefined
      }
    })

    if (signUpError) {
      console.error('‚ùå User creation error after OTP:', signUpError)
      return { 
        success: false, 
        message: `L·ªói t·∫°o t√†i kho·∫£n: ${signUpError.message}` 
      }
    }

    if (!signUpData.user) {
      return { 
        success: false, 
        message: 'Kh√¥ng th·ªÉ t·∫°o t√†i kho·∫£n ng∆∞·ªùi d√πng.' 
      }
    }

    console.log('‚úÖ User account created:', signUpData.user.id)

    // Step 5: Create organization with PENDING_ADMIN_APPROVAL status
    console.log('üè¢ Creating organization...')
    const { data: newOrg, error: orgError } = await supabase
      .from('organizations')
      .insert({
        name: registrationData.companyName,
        type: registrationData.organizationType,
        business_license_number: registrationData.taxCode,
        address: registrationData.address,
        phone_number: registrationData.phoneNumber,
        representative_email: registrationData.representativeEmail,
        representative_name: registrationData.fullName,
        status: 'PENDING_ADMIN_APPROVAL' // Waiting for admin approval
      })
      .select('id')
      .single()

    if (orgError) {
      console.error('‚ùå Organization creation error:', orgError)
      // Clean up user if organization creation fails
      const supabaseAdmin = createAdminClient()
      await supabaseAdmin.auth.admin.deleteUser(signUpData.user.id)
      return { 
        success: false, 
        message: `L·ªói t·∫°o t·ªï ch·ª©c: ${orgError.message}` 
      }
    }

    console.log('‚úÖ Organization created:', newOrg.id)

    // Step 6: Create user profile
    console.log('üë§ Creating user profile...')
    const { error: profileError } = await supabase
      .from('profiles')
      .insert({
        id: signUpData.user.id,
        full_name: registrationData.fullName,
        email: registrationData.email,
        organization_id: newOrg.id,
        role: 'DISPATCHER', // Default role
        status: 'PENDING' // Pending admin approval
      })

    if (profileError) {
      console.error('‚ùå Profile creation error:', profileError)
      // This is not critical, user can still login
    }

    // Step 7: Clean up temporary data
    tempRegistrationData.delete(email)

    console.log('üéâ Registration completed successfully!')
    return { 
      success: true, 
      message: 'ƒêƒÉng k√Ω th√†nh c√¥ng! T√†i kho·∫£n c·ªßa b·∫°n ƒëang ch·ªù admin ph√™ duy·ªát.',
      user: signUpData.user,
      organizationId: newOrg.id,
      requiresAdminApproval: true
    }

  } catch (error: any) {
    console.error('üí• Fatal error in verifyOtp:', error)
    return { 
      success: false, 
      message: `L·ªói h·ªá th·ªëng: ${error.message}` 
    }
  }
}

export async function resendOtp(email: string, type: OtpType) {
  try {
    console.log('üîÑ Resending OTP for:', email)
    
    // Check if registration data exists
    const tempData = tempRegistrationData.get(email)
    if (!tempData) {
      return { 
        success: false, 
        message: 'D·ªØ li·ªáu ƒëƒÉng k√Ω kh√¥ng t√¨m th·∫•y. Vui l√≤ng ƒëƒÉng k√Ω l·∫°i.' 
      }
    }

    // Generate new OTP
    const newOtpCode = Math.floor(100000 + Math.random() * 900000).toString()
    console.log('üîë New OTP generated:', newOtpCode)

    // Update stored data with new OTP and timestamp
    tempRegistrationData.set(email, {
      ...tempData,
      otpCode: newOtpCode,
      timestamp: Date.now() // Reset timestamp
    })

    // Send new OTP (simulated for now)
    console.log('üìß Sending new OTP to:', email)
    console.log('üì± New OTP Code:', newOtpCode)

    return { 
      success: true, 
      message: `M√£ OTP m·ªõi ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email: ${email}. M√£ OTP cho test: ${newOtpCode}` 
    }
  } catch (error: any) {
    console.error('üí• Error in resendOtp:', error)
    return { 
      success: false, 
      message: `L·ªói g·ª≠i l·∫°i m√£ OTP: ${error.message}` 
    }
  }
}

// Admin function to approve organization and create user profile
export async function approveOrganization(organizationId: string) {
  try {
    const supabase = await createClient()

    // Step 1: Update organization status to ACTIVE
    const { error: updateOrgError } = await supabase
      .from('organizations')
      .update({ status: 'ACTIVE' })
      .eq('id', organizationId)

    if (updateOrgError) {
      return { 
        success: false, 
        message: `L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i t·ªï ch·ª©c: ${updateOrgError.message}` 
      }
    }

    // Step 2: Find user associated with this organization (from user metadata)
    const supabaseAdmin = createAdminClient()
    const { data: users, error: usersError } = await supabaseAdmin.auth.admin.listUsers()

    if (usersError) {
      return { 
        success: false, 
        message: `L·ªói t√¨m ki·∫øm ng∆∞·ªùi d√πng: ${usersError.message}` 
      }
    }

    // Find user with matching pending_organization_id
    const associatedUser = users.users.find((user: any) => 
      user.user_metadata?.pending_organization_id === organizationId
    )

    if (!associatedUser) {
      return { 
        success: false, 
        message: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng li√™n k·∫øt v·ªõi t·ªï ch·ª©c n√†y' 
      }
    }

    // Step 3: Create user profile
    const userMetadata = associatedUser.user_metadata
    const { error: profileError } = await supabase
      .from('profiles')
      .upsert({
        id: associatedUser.id,
        full_name: userMetadata.full_name,
        organization_id: organizationId,
        role: userMetadata.organization_type === 'TRUCKING_COMPANY' ? 'DISPATCHER' : 'CARRIER_ADMIN'
      })

    if (profileError) {
      return { 
        success: false, 
        message: `L·ªói t·∫°o profile ng∆∞·ªùi d√πng: ${profileError.message}` 
      }
    }

    // Step 4: Update user metadata to clear pending organization
    const { error: updateUserError } = await supabaseAdmin.auth.admin.updateUserById(
      associatedUser.id,
      {
        user_metadata: {
          ...userMetadata,
          organization_id: organizationId,
          pending_organization_id: null // Clear pending status
        }
      }
    )

    if (updateUserError) {
      console.error('Error updating user metadata:', updateUserError)
      // Don't fail the process for this
    }

    return { 
      success: true, 
      message: 'T·ªï ch·ª©c ƒë√£ ƒë∆∞·ª£c duy·ªát v√† t√†i kho·∫£n ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t.',
      organizationId,
      userId: associatedUser.id
    }

  } catch (error: any) {
    console.error('Error in approveOrganization:', error)
    return { 
      success: false, 
      message: `L·ªói h·ªá th·ªëng: ${error.message}` 
    }
  }
}

// Admin function to reject organization (delete it and disable user)
export async function rejectOrganization(organizationId: string, reason: string) {
  try {
    const supabase = await createClient()
    const supabaseAdmin = createAdminClient()

    // Step 1: Find user associated with this organization
    const { data: users, error: usersError } = await supabaseAdmin.auth.admin.listUsers()

    if (usersError) {
      return { 
        success: false, 
        message: `L·ªói t√¨m ki·∫øm ng∆∞·ªùi d√πng: ${usersError.message}` 
      }
    }

    const associatedUser = users.users.find((user: any) => 
      user.user_metadata?.pending_organization_id === organizationId
    )

    // Step 2: Delete organization
    const { error: deleteOrgError } = await supabase
      .from('organizations')
      .delete()
      .eq('id', organizationId)

    if (deleteOrgError) {
      return { 
        success: false, 
        message: `L·ªói x√≥a t·ªï ch·ª©c: ${deleteOrgError.message}` 
      }
    }

    // Step 3: Update user metadata to reflect rejection
    if (associatedUser) {
      const { error: updateUserError } = await supabaseAdmin.auth.admin.updateUserById(
        associatedUser.id,
        {
          user_metadata: {
            ...associatedUser.user_metadata,
            organization_rejection_reason: reason,
            pending_organization_id: null,
            rejected_at: new Date().toISOString()
          }
        }
      )

      if (updateUserError) {
        console.error('Error updating user metadata after rejection:', updateUserError)
      }
    }

    return { 
      success: true, 
      message: 'Y√™u c·∫ßu ƒëƒÉng k√Ω t·ªï ch·ª©c ƒë√£ b·ªã t·ª´ ch·ªëi.',
      organizationId,
      userId: associatedUser?.id
    }

  } catch (error: any) {
    console.error('Error in rejectOrganization:', error)
    return { 
      success: false, 
      message: `L·ªói h·ªá th·ªëng: ${error.message}` 
    }
  }
}